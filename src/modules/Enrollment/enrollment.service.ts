import { StatusCodes } from 'http-status-codes';
import ApiError from '../../errors/ApiError';
import { EnrollmentModel } from './enrollment.model';
import { BatchModel } from '../Batch/batch.model';
import { BatchStatus, EnrollmentStatus } from '../../types/common';
import { ModuleModel } from '../Module/module.model';
import { ModuleProgressModel } from '../Progress/moduleProgress.model';
import { ProgressStatus } from '../../types/common';
import { sendEnrollmentConfirmationEmail } from '../../services/emailService';
import { UserModel } from '../User/user.model';
import { Status } from '../../types/common';
import { PaymentModel } from '../Payment/payment.model';
import mongoose from 'mongoose';
import crypto from 'crypto';
import { ProfileService } from '../Profile/profile.service';

/**
 * Generate unique enrollment ID
 */
const generateEnrollmentId = async (batch: string = '6'): Promise<string> => {
    const year = new Date().getFullYear();
    const count = await EnrollmentModel.countDocuments();
    const paddedCount = String(count + 1).padStart(5, '0');
    return `MA-${batch}${year}${paddedCount}`;
};

/**
 * Generate a unique transaction ID for payments
 * Format: TXN-{timestamp}-{random}
 */
const generateTransactionId = (): string => {
    const timestamp = Date.now();
    const random = crypto.randomBytes(4).toString('hex').toUpperCase();
    return `TXN-${timestamp}-${random}`;
};

/**
 * Initiate enrollment for a batch
 * With idempotency - returns existing pending enrollment if found
 */
const initiateEnrollment = async (userId: string, batchId: string) => {
    // Check if user has pending enrollment for this batch (idempotency)
    const existingPendingEnrollment = await EnrollmentModel.findOne({
        userId,
        batchId,
        status: { $in: [EnrollmentStatus.Pending, EnrollmentStatus.PaymentPending] }
    }).populate('batchId');

    if (existingPendingEnrollment) {
        // Return existing pending enrollment instead of creating duplicate
        return {
            enrollment: existingPendingEnrollment,
            batch: existingPendingEnrollment.batchId,
            isExisting: true,
        };
    }

    // Check if batch exists and is accepting enrollments
    const batch = await BatchModel.findById(batchId).populate('courseId');

    if (!batch) {
        throw new ApiError(StatusCodes.NOT_FOUND, 'Batch not found');
    }

    // Check batch status
    if (batch.status !== BatchStatus.Upcoming && batch.status !== BatchStatus.Running) {
        throw new ApiError(
            StatusCodes.BAD_REQUEST,
            'This batch is not accepting new enrollments'
        );
    }

    // Check enrollment window
    const now = new Date();
    if (now > batch.enrollmentEndDate) {
        throw new ApiError(StatusCodes.BAD_REQUEST, 'Enrollment period has ended for this batch');
    }

    // Check if user already enrolled in THIS batch
    const existingEnrollment = await EnrollmentModel.findOne({
        userId,
        batchId,
    });

    if (existingEnrollment) {
        throw new ApiError(
            StatusCodes.CONFLICT,
            'You are already enrolled in this batch'
        );
    }

    // Check if user is enrolled in a CURRENT (running/upcoming) batch of the same course
    // Only allow one active enrollment per course at a time
    const courseId = batch.courseId;
    const existingCourseEnrollment = await EnrollmentModel.findOne({
        userId,
        status: { $in: [EnrollmentStatus.Active, EnrollmentStatus.Pending] }
    }).populate({
        path: 'batchId',
        match: {
            courseId,
            status: { $in: [BatchStatus.Upcoming, BatchStatus.Running] }
        }
    });

    if (existingCourseEnrollment && existingCourseEnrollment.batchId) {
        throw new ApiError(
            StatusCodes.CONFLICT,
            'You are already enrolled in a current batch of this course. You can only enroll in one batch at a time.'
        );
    }

    // Create pending enrollment (without enrollmentId initially)
    const enrollment = await EnrollmentModel.create({
        userId,
        batchId,
        status: EnrollmentStatus.Pending,
    });

    return {
        enrollment,
        batch,
        isExisting: false,
    };
};

/**
 * Confirm enrollment after successful payment
 * Provides lifetime access - no expiry unless user is suspended
 * Idempotent - can be called multiple times safely (webhook + redirect)
 */
const confirmEnrollment = async (enrollmentId: string, paymentId: string) => {
    const enrollment = await EnrollmentModel.findOne({ enrollmentId });

    if (!enrollment) {
        throw new ApiError(StatusCodes.NOT_FOUND, 'Enrollment not found');
    }

    // Idempotency: If already active, just return it
    if (enrollment.status === EnrollmentStatus.Active) {
        return enrollment;
    }

    if (enrollment.status !== EnrollmentStatus.Pending && enrollment.status !== EnrollmentStatus.PaymentPending) {
        throw new ApiError(StatusCodes.BAD_REQUEST, `Cannot confirm enrollment with status: ${enrollment.status}`);
    }

    // const mongoose = require('mongoose');
    const session = await mongoose.startSession();

    try {
        await session.startTransaction();

        // Update enrollment - LIFETIME ACCESS (no expiry date)
        enrollment.status = EnrollmentStatus.Active;
        enrollment.paymentId = paymentId as any;
        enrollment.enrolledAt = new Date();

        await enrollment.save({ session });

        // Increment batch enrollment count (only if not already incremented)
        const batch = await BatchModel.findById(enrollment.batchId);
        if (batch) {
            await BatchModel.findByIdAndUpdate(
                enrollment.batchId,
                { $inc: { currentEnrollment: 1 } },
                { session }
            );
        }

        // Initialize module progress when batch starts
        await initializeModuleProgress(enrollment._id.toString(), enrollment.batchId.toString());

        await session.commitTransaction();

        // AUTOMATIC PROFILE CREATION/UPDATE - Single source of truth
        // This runs after enrollment confirmation regardless of payment method
        try {
            await ProfileService.createOrUpdateProfileAfterEnrollment(
                enrollment.userId.toString(),
                enrollment.enrollmentId!
            );
        } catch (profileError) {
            // Log error but don't fail enrollment - profile can be synced later
            console.error('Failed to update student profile after enrollment:', profileError);
        }

        // Send enrollment confirmation email (async, don't block)
        setImmediate(async () => {
            try {
                const user = await UserModel.findById(enrollment.userId);
                const batchData = await BatchModel.findById(enrollment.batchId).populate('courseId');
                if (user && batchData && batchData.courseId) {
                    sendEnrollmentConfirmationEmail(
                        user,
                        (batchData.courseId as any).title || 'Unknown Course',
                        enrollment.enrollmentId || 'N/A'
                    );
                }
            } catch (emailError) {
                console.error('Failed to send enrollment confirmation email:', emailError);
            }
        });

        return enrollment;
    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        session.endSession();
    }
};

/**
 * Initialize module progress for an enrollment
 * Idempotent - checks if already initialized
 */
const initializeModuleProgress = async (enrollmentId: string, batchId: string) => {
    // Check if already initialized
    const existingProgress = await ModuleProgressModel.findOne({ enrollmentId });
    if (existingProgress) {
        return; // Already initialized, skip
    }

    const batch = await BatchModel.findById(batchId).populate('courseId');

    if (!batch) return;

    // Get all modules for the course
    const modules = await ModuleModel.find({ courseId: batch.courseId }).sort({ orderIndex: 1 });

    if (modules.length === 0) return;

    // Create progress records for all modules
    // First module is unlocked by default, others are locked
    const progressRecords = modules.map((module, index) => ({
        enrollmentId,
        moduleId: module._id,
        status: index === 0 ? ProgressStatus.Unlocked : ProgressStatus.Locked,
        unlockedAt: index === 0 ? new Date() : undefined,
        completionPercentage: 0,
    }));

    await ModuleProgressModel.insertMany(progressRecords, { ordered: false });
};

/**
 * Get user's enrollments
 */
const getUserEnrollments = async (userId: string, status?: EnrollmentStatus) => {
    const query: any = { userId };
    if (status) query.status = status;

    const enrollments = await EnrollmentModel.find(query)
        .populate({
            path: 'batchId',
            populate: {
                path: 'courseId',
                select: 'title thumbnailImage category level',
            },
        })
        .sort({ createdAt: -1 })
        .lean();

    // Add progress for each enrollment
    const enrollmentsWithProgress = await Promise.all(
        enrollments.map(async (enrollment) => {
            const moduleProgress = await ModuleProgressModel.find({ enrollmentId: enrollment._id });

            const totalModules = moduleProgress.length;
            const completedModules = moduleProgress.filter(
                (p) => p.status === ProgressStatus.Completed
            ).length;
            const overallProgress =
                totalModules > 0 ? Math.round((completedModules / totalModules) * 100) : 0;

            return {
                ...enrollment,
                progress: {
                    totalModules,
                    completedModules,
                    overallProgress,
                },
            };
        })
    );

    return enrollmentsWithProgress;
};

/**
 * Get enrollment details
 */
const getEnrollmentDetails = async (enrollmentId: string, userId: string) => {
    const enrollment = await EnrollmentModel.findOne({
        _id: enrollmentId,
        userId,
    })
        .populate({
            path: 'batchId',
            populate: [
                {
                    path: 'courseId',
                },
                {
                    path: 'instructors',
                    populate: 'userId',
                },
            ],
        })
        .lean();

    if (!enrollment) {
        throw new ApiError(StatusCodes.NOT_FOUND, 'Enrollment not found');
    }

    // Get progress statistics
    const moduleProgress = await ModuleProgressModel.find({ enrollmentId });

    const totalModules = moduleProgress.length;
    const completedModules = moduleProgress.filter(
        (p) => p.status === ProgressStatus.Completed
    ).length;
    const overallProgress =
        totalModules > 0 ? Math.round((completedModules / totalModules) * 100) : 0;

    return {
        ...enrollment,
        progress: {
            totalModules,
            completedModules,
            overallProgress,
        },
    };
};

/**
 * Enroll student with manual payment
 * Creates enrollment in PaymentPending status awaiting admin verification
 */
const enrollWithManualPayment = async (
    userId: string,
    batchId: string,
    paymentData: { senderNumber: string; transactionId: string }
) => {
    // Check if user has any pending enrollment for this batch
    const existingEnrollment = await EnrollmentModel.findOne({
        userId,
        batchId,
        status: { $in: [EnrollmentStatus.Pending, EnrollmentStatus.PaymentPending, EnrollmentStatus.Active] }
    });

    if (existingEnrollment) {
        if (existingEnrollment.status === EnrollmentStatus.Active) {
            throw new ApiError(StatusCodes.CONFLICT, 'You are already enrolled in this batch');
        }
        throw new ApiError(
            StatusCodes.CONFLICT,
            'You already have a pending enrollment for this batch. Please wait for payment verification.'
        );
    }

    // Validate batch
    const batch = await BatchModel.findById(batchId).populate('courseId');
    if (!batch) {
        throw new ApiError(StatusCodes.NOT_FOUND, 'Batch not found');
    }

    if (batch.status !== BatchStatus.Upcoming && batch.status !== BatchStatus.Running) {
        throw new ApiError(StatusCodes.BAD_REQUEST, 'This batch is not accepting enrollments');
    }

    const now = new Date();
    // now < batch.enrollmentStartDate ||
    if (now > batch.enrollmentEndDate) {
        throw new ApiError(StatusCodes.BAD_REQUEST, 'Enrollment period is not active');
    }

    // Use MongoDB transaction for atomicity
    const session = await mongoose.startSession();

    try {
        await session.startTransaction();

        // Create enrollment with PaymentPending status (no enrollmentId yet)
        const enrollment = await EnrollmentModel.create([{
            userId,
            batchId,
            status: EnrollmentStatus.PaymentPending,
        }], { session });

        // Generate unique transaction ID for the payment
        const paymentTransactionId = generateTransactionId();

        // Create payment record in Review status (no enrollmentId linked yet)
        await PaymentModel.create([{
            userId,
            batchId,
            transactionId: paymentTransactionId,
            // idempotencyKey: paymentTransactionId,
            amount: batch.price,
            currency: batch.currency || 'BDT',
            status: Status.Review,
            method: 'PhonePay',
            gatewayResponse: {
                senderNumber: paymentData.senderNumber,
                phonePeTransactionId: paymentData.transactionId, // Store the PhonePe transaction ID
                submittedAt: new Date(),
            },
        }], { session });

        await session.commitTransaction();

        return {
            enrollment: enrollment[0],
            batch,
            transactionId: paymentTransactionId,
            message: 'Payment submitted for verification. You will receive confirmation within 12-24 hours.',
        };
    } catch (error) {
        await session.abortTransaction();
        throw error;
    } finally {
        session.endSession();
    }
};

export const EnrollmentService = {
    initiateEnrollment,
    confirmEnrollment,
    enrollWithManualPayment,
    getUserEnrollments,
    getEnrollmentDetails,
    initializeModuleProgress,
    generateEnrollmentId, // Export this function
};
